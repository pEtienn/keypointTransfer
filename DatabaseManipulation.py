# -*- coding: utf-8 -*-
"""
Created on Tue Aug 13 20:51:52 2019

@author: Etenne Pepyn
"""
import os
from pathlib import Path
import numpy as np 
import nibabel as nib
import re
from numba import guvectorize,float64,int64
import shutil
import csv

"""
EXAMPLE for CombineSegmentations and SelectLabelInSegmentation
srcPath=r'S:/Anatomy3-trainingset/segTest'
CombineSegmentations(srcPath,srcPath+'New')
SelectLabelInSegmentation(srcPath+'New',srcPath+'NewSelectedLabel',[29663,29662,30325,30324])
GetNumberPatientContainingLabel(srcPath+'NewSelectedLabel',[]) #to check if the labels were present and copied
"""

def CombineSegmentations(srcPath,outPath):
    """
    Takes segmentation files of the Visceral dataset and creates a new set of files.
    There's one new file per patient, containing all segmentations.
    Funciton skips files causing problems.
     *** INPUT ***
    srcPath: path of the segmentation folder
    """

    rLabelNumber=re.compile('(wb|Ab)_([0-9]+)_')
    rVolumeID=re.compile('(^.+[wb|Ab])_')
    srcPath=str(Path(srcPath))
    outPath=str(Path(outPath))
    allF=os.listdir(srcPath)
    unreadableFile=' '
    previousOutput=' '
    affine = np.diag([1, 2, 3, 1])

    for f in allF:  
        shortName=rVolumeID.findall(f)[0]

        if shortName!=unreadableFile:
            outputName=(os.path.join(outPath,shortName+'.nii.gz'))
            try:
                img=nib.load(os.path.join(srcPath,f))
                arr=img.get_fdata()

            except:
                print('problem loading '+f+', skipping '+shortName)
                unreadableFile=shortName

                
            if shortName!=unreadableFile:
                if previousOutput!=outputName:

                    h=img.header
                    shape=h.get_data_shape()   
                    if previousOutput!=' ' and previousOutput!= os.path.join(outPath,unreadableFile+'.nii.gz'):

                        print(previousOutput)
                        segArray=np.int32(segArray)
                        arrayImg = nib.Nifti1Image(segArray,affine=None,header=h)

                        nib.save(arrayImg,previousOutput) 
                    segArray=np.zeros(shape)
                
                uni=np.unique(arr)
                if np.shape(uni)[0]==2:
                    k=rLabelNumber.findall(f)[0][1]
                    n=int(k)
                    if uni[1]!=n:  
                        arr=(arr>0)*n
                else:
                    arr=0
                segArray=segArray+arr*(segArray==0)
        previousOutput=outputName
    
    if shortName!=unreadableFile:
        segArray=np.int32(segArray)
        arrayImg = nib.Nifti1Image(segArray, affine=None,header=h)
        nib.save(arrayImg,outputName) 
        
    print(previousOutput)

def SelectLabelInSegmentation(srcPath,outPath,labelToKeep):
    """
    Takes all the segmentation files generated by CombineSegmentations and generates new
    segmentations files containing only labels specified by labelToKeep
     *** INPUT ***
    srcPath: path of the output of CombineSegmentations
    outPath: destination of new segmentations files
    labelToKeep: list containing labels to keep
    """
    affine = np.diag([1, 2, 3, 1])
    allF=os.listdir(srcPath)
    for f in allF: 
        img=nib.load(os.path.join(srcPath,f))
        arr=img.get_fdata()
        h=img.header
        outArr=np.zeros(arr.shape)
        for i in range(len(labelToKeep)):
            outArr=outArr+(arr==labelToKeep[i])*labelToKeep[i]
        arrayImg = nib.Nifti1Image(outArr,affine=None,header=h)
        nib.save(arrayImg,os.path.join(outPath,f)) 
        
def GetLabelInPatient(srcPath,labelList):
    """
    Tool to check the presence of some labels in combined segmentation files, 
    or all the labels present if labelList=[]
     *** INPUT ***
    srcPath:folder containing combined segmentation files
    labelList: either list of labels you want to verify the presence,
            or empty, to show all the labels present in each file
     *** OUTPUT ***
    The present labels will be shown on the console after the name of the file
    allLabels: matrix n*2, 
            colums: labelNb | nb Of Patient With That Label     
    """
    np.set_printoptions(precision=3)
    allF=os.listdir(srcPath)
    allLabels=np.zeros((1,2),dtype=np.int64)

    for f in allF: 
        img=nib.load(os.path.join(srcPath,f))
        arr=img.get_fdata()
        print (f,end=" ")
        if not labelList :
            u=np.unique(arr)
            for l in u:
                print(l,end=" ")
                if np.sum(l==allLabels[:,0],0)==0:
                    allLabels=np.concatenate((allLabels,np.array([[int(l),1]])),axis=0)
                else:
                    allLabels[allLabels[:,0]==l,1]+=1
        else:
            for l in labelList:
                if np.sum(arr==l)!=0:
                    print(l,end=" ")
                    if np.sum(l==allLabels[:,0],0)==0:
                        allLabels=np.concatenate((allLabels,np.array([[int(l),1]])),axis=0)
                    else:
                        allLabels[allLabels[:,0]==l,1]+=1
        print(' ')
        if np.sum(allLabels==256)>0:
            pass
    return allLabels[allLabels[:,0].argsort()]

def FilterPatientsByLabel(srcPath,outPath,labelList):
    outPath=str(Path(outPath))
    srcPath=str(Path(srcPath))
    allF=os.listdir(srcPath)
    
    for f in allF:
        img=nib.load(os.path.join(srcPath,f))
        arr=np.squeeze(img.get_fdata())
        arr2=np.zeros(arr.shape)
        allPresent=1
        for i in labelList:
            if np.sum(arr==i)>0:
                arr2[arr==i]=arr[arr==i]
            else:
                allPresent=0
                break
        if allPresent==1:
            im2=nib.Nifti1Image(arr2,affine=None,header=img.header)
            nib.save(im2,os.path.join(outPath,f))

def GetCropSize(path):
    path=str(Path(path))
    allF=os.listdir(path)
    maxXYZ=np.zeros((3,2),dtype=np.int64)
    imageBoxCenter=np.zeros((len(allF),3))
    for j in range(len(allF)):
        f=allF[j]
        img=nib.load(os.path.join(path,f))
        arr=np.float32(np.squeeze(img.get_fdata()))
        a=np.nonzero(arr)
        XYZ=np.zeros((3,2),dtype=np.int64)
        for i in range(3):
            XYZ[i,0]=np.min(a[i])
            XYZ[i,1]=np.max(a[i])+1
#        print(XYZ)
        imageBoxCenter[j,:]=np.mean(XYZ,axis=1)
        print(arr.shape)
        sizeXYZ=XYZ[:,1]-XYZ[:,0]
        if np.sum(maxXYZ)==0:
            maxXYZ=sizeXYZ
        else:
            maxXYZ=np.maximum(maxXYZ,sizeXYZ)
    maxXYZ=np.ceil(maxXYZ)
    maxXYZ=(maxXYZ+maxXYZ%2)/2
    return [np.int64(maxXYZ), np.int64(imageBoxCenter)]

def Crop(srcPath,outPath,XYZ,imageBoxCenter,margin=[0,0,0],decompress=True):
    """
    Crop all images in path
    XYZ: output from GetCropBoundaries
    Margin: [x,y,z] margin to add to the boudary boxes, the margin will be added 2 times on each axis
    *** OUTPUT ***
     modify directly the images
     """
    margin=np.int64(margin)
    XYZ=np.int64(XYZ)
    imageBoxCenter=np.int64(imageBoxCenter)
    outPath=str(Path(outPath))
    srcPath=str(Path(srcPath))
    allF=os.listdir(srcPath) 
    for i in range(len(allF)):
        f=allF[i]
        img=nib.load(os.path.join(srcPath,f))
        arr=np.int16(np.squeeze(img.get_fdata()))
        nh=img.header
        cubeLimit=np.zeros((3,2))
        for j in range(3):
                cubeLimit[j,0]=max(imageBoxCenter[i,j]-XYZ[j]-margin[j],0)
                cubeLimit[j,1]=min(imageBoxCenter[i,j]+XYZ[j]+margin[j]-1,arr.shape[j]-1)
        cubeLimit=np.int64(cubeLimit)
        newArr=arr[cubeLimit[0,0]:cubeLimit[0,1],cubeLimit[1,0]:cubeLimit[1,1],cubeLimit[2,0]:cubeLimit[2,1]]
        imgv2=nib.Nifti1Image(newArr,affine=None,header=nh)
        if decompress==True:
            nib.save(imgv2,os.path.join(outPath,f[:-3]))
        else:
            nib.save(imgv2,os.path.join(outPath,f))
            
def Rename(srcPath,suffix,extension='.nii.gz',numberDetectionRegex='^[0-9]*([0-9]{4})_'):
    rPatientNumber=re.compile(numberDetectionRegex)
    srcPath=str(Path(srcPath))
    allF=os.listdir(srcPath) 
    for f in allF:
        num=rPatientNumber.findall(f)[0]
        os.rename(os.path.join(srcPath,f),os.path.join(srcPath,num+suffix+extension))
        
def GetCorrespondingVolumes(volumesPath,outPath,labelPath,volumeID='^(.+)[wb|Ab]'):
    rVolumeID=re.compile(volumeID)
    volumesPath=str(Path(volumesPath))
    outPath=str(Path(outPath))
    labelPath=str(Path(labelPath))
    
    allHdrF=os.listdir(volumesPath)
    allLabelF=os.listdir(labelPath) #we take only hdr files that also have a label
    for f in allLabelF:
        num=rVolumeID.findall(f)[0]
        hdrF=[x for x in allHdrF if (num in x)][0]
        img=nib.load(os.path.join(volumesPath,hdrF))
        nib.save(img,os.path.join(outPath,hdrF))
        
def StandardizeLabels(srcPath,outPath,labels):
    srcPath=str(Path(srcPath))
    allF=os.listdir(srcPath) 
    for f in allF:
        img=nib.load(os.path.join(srcPath,f))
        arr=np.int16(np.squeeze(img.get_fdata()))
        nh=img.header
        for i in range(len(labels)):
            arr[arr==labels[i]]=i
        imgv2=nib.Nifti1Image(arr,affine=None,header=nh)
        nib.save(imgv2,os.path.join(outPath,f))
        
def GetDataVolumesInfo(path):
    srcPath=str(Path(path))
    allF=os.listdir(srcPath) 
    for f in allF:
        img=nib.load(os.path.join(srcPath,f))
        arr=np.squeeze(img.get_fdata())
        h=img.header
        print('shape: ',arr.shape,'\t pixDim: ',h.get_zooms())


                    
                    
@guvectorize([(float64[:,:,:],float64[:,:,:],float64[:,:,:])], '(x,y,z),(a,b,c)->(a,b,c)',nopython=True)
def ImResize3D(im,dum,im2):
    """
     resizes 3D image using NN
     *** INPUT ***
    im: image
    dum: dummy array to have dimensions for the output array
    im2: output array
     *** OUTPUT ***
    new resized Image
    """
    newDim=np.asarray(dum.shape)
    oldDim=np.asarray(im.shape)
    for x in range(newDim[0]):
        for y in range(newDim[1]):
            for z in range(newDim[2]):
                im2[x,y,z]=im[np.int64(np.round_((oldDim[0]-1)/(newDim[0]-1)*x)),np.int64(np.round_((oldDim[1]-1)/(newDim[1]-1)*y)),np.int64(np.round_((oldDim[2]-1)/(newDim[2]-1)*z))]
                
def NormalizePixDimensions(folderPath,outPath):
    path=str(Path(folderPath))
    outPath=str(Path(outPath))
    allF=os.listdir(path) 
    for f in allF:
        img=nib.load(os.path.join(path,f))
        arr=np.squeeze(img.get_fdata())
        h=img.header
        pixDim=np.asarray(h.get_zooms())
        oldDim=np.asarray(arr.shape)
        newDim=np.int64(np.multiply(np.float32(oldDim),pixDim))
        newArr=np.zeros(newDim)
        dum=np.copy(newArr)
        ImResize3D(arr,dum,newArr)
        h.set_zooms((1,1,1))
        imgv2=nib.Nifti1Image(newArr,affine=None,header=h)
        nib.save(imgv2,os.path.join(outPath,f))
        print(f)
        
def PrepareData(labelPath,mriPath,outPath,labelList):
    """
     prepare data for the dense vnet
     *** INPUT ***
    labelPath:path containing result of CombineSegmentation
    mriPath: path containing needed volumes (or more)
    outputPath: path to output the prepared data
    labelList: labels that image in the database must contain
     *** OUTPUT ***
    Images in the outputPath ready for the denseVnet
    normalized pixel dimension
    All cropped at the same window size
    Renamed
    Labels are go from 0 to n
    
    """
    labelPath=str(Path(labelPath))
    mriPath=str(Path(mriPath))
    outPath=str(Path(outPath))
    tFN=10
    tempPathList=[]
    for i in range(tFN):
        tempPathList.append(os.path.join(outPath,'tp'+str(i)))
        os.makedirs(tempPathList[i])
    FilterPatientsByLabel(labelPath,tempPathList[0],labelList)
    GetCorrespondingVolumes(mriPath,tempPathList[1],tempPathList[0])
    NormalizePixDimensions(tempPathList[0],tempPathList[2])
    NormalizePixDimensions(tempPathList[1],tempPathList[3])
    [XYZ,centers]=GetCropSize(tempPathList[2])
    Crop(tempPathList[2],tempPathList[4],XYZ,centers)
    Rename(tempPathList[3],'_MRI',extension='.nii.gz')
    Crop(tempPathList[3],outPath,XYZ,centers)
    Rename(tempPathList[4],'_Label',extension='.nii')
    StandardizeLabels(tempPathList[4],outPath,labelList)
    for i in range(tFN):
        shutil.rmtree(tempPathList[i])
    
    
    return XYZ


def CreateCSVFile(path):
    regNumber='(^[0-9]{4})_'
    reg=re.compile(regNumber)
    path=str(Path(path))
    csvFile=os.path.join(path,'dataset_split_file.csv')
    allF=os.listdir(path)
    previousNumber=''
    csvData=[]
    for i in range(len(allF)):
       patientNumber=reg.findall(allF[i])[0]
       if patientNumber != previousNumber:
          csvData.append([patientNumber,'training'])
    with open(csvFile, 'w',newline='') as csvFile:
        writer = csv.writer(csvFile)
        writer.writerows(csvData)
    csvFile.close()
